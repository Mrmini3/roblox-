--!strict
-- Basic sanity checks + rate limits (MemoryStore w/ fallback)
local MemoryStoreService = game:GetService("MemoryStoreService")
local Players = game:GetService("Players")

local Anti = {}
Anti._msm = nil :: MemoryStoreSortedMap?
Anti._localWindow = {} :: {[string]: {count: number, resetAt: number}}

function Anti:Init()
	local ok, map = pcall(function()
		return MemoryStoreService:GetSortedMap("CivicClash_RateLimits_v1")
	end)
	if ok then self._msm = map end
end

function Anti:Start() end

local function now(): number
	return os.clock()
end

function Anti:_localAllow(key: string, maxPerWindow: number, windowSec: number): boolean
	local bucket = self._localWindow[key]
	local t = now()
	if not bucket or t >= bucket.resetAt then
		self._localWindow[key] = {count = 1, resetAt = t + windowSec}
		return true
	end
	if bucket.count < maxPerWindow then
		bucket.count += 1
		return true
	end
	return false
end

function Anti:Allow(player: Player, scope: string, maxPerWindow: number, windowSec: number): boolean
	local key = ("%d:%s"):format(player.UserId, scope)
	if not self:_localAllow(key, maxPerWindow, windowSec) then
		return false
	end
	if not self._msm then
		return true
	end
	local ok, allowed = pcall(function()
		return self._msm:UpdateAsync(key, function(old)
			local data = old or {count=0, resetAt=now()+windowSec}
			if now() >= data.resetAt then
				data.count = 0
				data.resetAt = now() + windowSec
			end
			if data.count < maxPerWindow then
				data.count += 1
				return data
			else
				return nil
			end
		end)
	end)
	return ok and allowed ~= nil
end

function Anti:ValidateNumber(n: any, minVal: number?, maxVal: number?): boolean
	if typeof(n) ~= "number" then return false end
	if minVal and n < minVal then return false end
	if maxVal and n > maxVal then return false end
	return true
end

function Anti:KickIfInvalid(player: Player, reason: string)
	warn(("[AntiExploit] %s (%d): %s"):format(player.Name, player.UserId, reason))
	player:Kick("Invalid network request.")
end

return Anti
